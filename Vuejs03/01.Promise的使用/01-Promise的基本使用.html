<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			// 1. 使用setTimeout
			// setTimeout(()=>{
			// 	console.log('Hello world')
			// },1000)

			// 参数 -> 函数
			// resolve和reject本身它们又是函数
			// 链式编程
			// new Promise((resolve, reject) => {
			// 	// 第一次网络请求的代码
			// 	setTimeout(() => {
			// 		resolve()
			// 	}, 1000)
			// }).then(() => {
			// 	// 第一次拿到结果处理代码
			// 	console.log('Hello world')
			// 	console.log('Hello world')
			// 	console.log('Hello world')
			// 	console.log('Hello world')
			// 	console.log('Hello world')
			// 	return new Promise((resolve, reject) => {
			// 		// 第二次网络请求的代码
			// 		setTimeout(() => {
			// 			resolve()
			// 		}, 1000)
			// 	}).then(() => {
			// 		// 第二次拿到结果处理代码
			// 		console.log('Hello Vuejs')
			// 		console.log('Hello Vuejs')
			// 		console.log('Hello Vuejs')
			// 		console.log('Hello Vuejs')
			// 		console.log('Hello Vuejs')
			// 		return new Promise((resolve, reject) => {
			// 			// 第三次网络请求的代码
			// 			setTimeout(() => {
			// 				resolve()
			// 			}, 1000)
			// 		}).then(() => {
			// 			// 第三次拿到结果处理代码
			// 			console.log('Hello PHP')
			// 			console.log('Hello PHP')
			// 			console.log('Hello PHP')
			// 			console.log('Hello PHP')
			// 			console.log('Hello PHP')
			// 		})
			// 	})
			// })


			// 什么情况下会用到Promise？
			// 一般情况下是有异步操作时使用Promise对异步操作进行封装
			// new -> 构造函数（1.保存一些状态信息，2.执行传入的函数）
			// 在执行传入的回调函数时，会传入两个参数，resolve,reject本身又是函数
			new Promise((resolve, reject) => {
				setTimeout(() => {
					//成功的时候调用resolve
					//resolve('Hello World')
					//失败的时候调用reject
					reject('error message')
				}, 1000)
			}).then((data) => {
				console.log(data)
				console.log(data)
				console.log(data)
				console.log(data)
			}).catch((err) => {
				console.log(err)
				console.log(err)
				console.log(err)
				console.log(err)
			})
		</script>
	</body>
</html>
